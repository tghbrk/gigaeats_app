import 'dart:convert';
import 'dart:io';

import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../orders/data/models/order.dart';
import '../../../payments/data/services/payment_service.dart';
import '../models/customer_profile.dart';

import '../../presentation/providers/customer_cart_provider.dart';
import '../../../../core/utils/logger.dart';

/// Customer order service for handling order creation and payment processing
class CustomerOrderService {
  final SupabaseClient _supabase = Supabase.instance.client;
  final PaymentService _paymentService;
  final AppLogger _logger = AppLogger();

  CustomerOrderService({PaymentService? paymentService})
      : _paymentService = paymentService ?? PaymentService();

  /// Create order from customer cart
  Future<Order> createOrderFromCart({
    required CustomerCartState cartState,
    required CustomerProfile customerProfile,
    required String paymentMethod,
    String? specialInstructions,
  }) async {
    try {
      _logger.info('CustomerOrderService: Creating order from cart');

      // Validate cart state
      if (cartState.isEmpty) {
        throw Exception('Cart is empty');
      }

      if (cartState.selectedAddress == null) {
        throw Exception('Delivery address is required');
      }

      // Get current user
      final user = _supabase.auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      // Convert cart items to order items
      final orderItems = cartState.items.map((cartItem) => OrderItem(
        id: '', // Will be generated by database
        menuItemId: cartItem.productId,
        name: cartItem.name,
        description: cartItem.description,
        unitPrice: cartItem.unitPrice,
        quantity: cartItem.quantity,
        totalPrice: cartItem.totalPrice,
        customizations: cartItem.customizations,
        notes: cartItem.notes,
      )).toList();

      // Get vendor information from first item
      final firstItem = cartState.items.first;
      final vendorId = firstItem.vendorId;

      // Convert customer address to order address
      final customerAddr = cartState.selectedAddress!;
      final deliveryAddress = Address(
        street: '${customerAddr.addressLine1}${customerAddr.addressLine2 != null ? ', ${customerAddr.addressLine2}' : ''}',
        city: customerAddr.city,
        state: customerAddr.state,
        postalCode: customerAddr.postalCode,
        country: customerAddr.country,
        notes: customerAddr.deliveryInstructions,
      );

      // Map customer delivery method to order delivery method
      String deliveryMethodValue;
      switch (cartState.deliveryMethod) {
        case CustomerDeliveryMethod.pickup:
          deliveryMethodValue = 'customer_pickup';
          break;
        case CustomerDeliveryMethod.delivery:
        case CustomerDeliveryMethod.scheduled:
          deliveryMethodValue = 'own_fleet'; // Use own fleet for delivery
          break;
      }

      // Determine delivery date/time
      DateTime deliveryDateTime;
      if (cartState.deliveryMethod == CustomerDeliveryMethod.scheduled &&
          cartState.scheduledDeliveryTime != null) {
        deliveryDateTime = cartState.scheduledDeliveryTime!;
      } else {
        deliveryDateTime = DateTime.now().add(const Duration(days: 1));
      }

      // Prepare order data for Edge Function
      final orderData = {
        'vendor_id': vendorId,
        'customer_id': customerProfile.id,
        'delivery_method': deliveryMethodValue, // Include delivery method
        'delivery_date': deliveryDateTime.toIso8601String(),
        'scheduled_delivery_time': cartState.scheduledDeliveryTime?.toIso8601String(),
        'delivery_address': {
          'street': deliveryAddress.street,
          'city': deliveryAddress.city,
          'state': deliveryAddress.state,
          'postal_code': deliveryAddress.postalCode,
          'country': deliveryAddress.country,
          'notes': deliveryAddress.notes,
        },
        'items': orderItems.map((item) => {
          'menu_item_id': item.menuItemId,
          'quantity': item.quantity,
          'unit_price': item.unitPrice,
          'customizations': item.customizations,
          'notes': item.notes,
        }).toList(),
        'special_instructions': specialInstructions ?? cartState.specialInstructions,
        'contact_phone': customerProfile.phoneNumber,
      };

      _logger.info('CustomerOrderService: Calling validate-order-v3 Edge Function');
      _logger.info('CustomerOrderService: Customer ID being sent: ${customerProfile.id}');
      _logger.info('CustomerOrderService: Cart delivery method: ${cartState.deliveryMethod}');
      _logger.info('CustomerOrderService: Mapped delivery method: $deliveryMethodValue');
      _logger.info('CustomerOrderService: Order data: $orderData');

      // Create order using Edge Function (using validate-order-v3 which properly handles delivery_method)
      final response = await _supabase.functions.invoke(
        'validate-order-v3',
        body: {'orderData': orderData},
      );

      if (response.status != 200) {
        throw Exception('Failed to create order: HTTP ${response.status}');
      }

      final responseData = response.data;
      if (responseData['success'] != true) {
        final errors = responseData['errors'] as List?;
        final errorMessage = errors?.isNotEmpty == true 
            ? errors!.first.toString() 
            : 'Unknown error occurred';
        throw Exception('Order validation failed: $errorMessage');
      }

      final orderJson = responseData['order'];
      _logger.info('CustomerOrderService: Order created successfully with ID: ${orderJson['id']}');

      // Convert response to Order object
      final order = Order.fromJson(orderJson);
      
      return order;
    } catch (e) {
      _logger.error('CustomerOrderService: Error creating order', e);
      rethrow;
    }
  }

  /// Process payment for an order
  Future<Map<String, dynamic>> processPayment({
    required String orderId,
    required double amount,
    required String paymentMethod,
    String currency = 'myr',
  }) async {
    try {
      _logger.info('CustomerOrderService: Processing payment for order $orderId');

      if (paymentMethod == 'credit_card') {
        // Create payment intent for credit card
        final paymentResult = await _paymentService.createPaymentIntent(
          orderId: orderId,
          amount: amount,
          currency: currency,
        );

        _logger.info('CustomerOrderService: Payment intent created successfully');
        return paymentResult;
      } else if (paymentMethod == 'cash') {
        // For cash on delivery, just update order status
        await _updateOrderPaymentMethod(orderId, 'cash');
        return {
          'success': true,
          'payment_method': 'cash',
          'status': 'pending',
        };
      } else {
        throw Exception('Unsupported payment method: $paymentMethod');
      }
    } catch (e) {
      _logger.error('CustomerOrderService: Error processing payment', e);
      rethrow;
    }
  }

  /// Update order payment method
  Future<void> _updateOrderPaymentMethod(String orderId, String paymentMethod) async {
    try {
      await _supabase
          .from('orders')
          .update({
            'payment_method': paymentMethod,
            'updated_at': DateTime.now().toIso8601String(),
          })
          .eq('id', orderId);

      _logger.info('CustomerOrderService: Updated order payment method to $paymentMethod');
    } catch (e) {
      _logger.error('CustomerOrderService: Error updating order payment method', e);
      rethrow;
    }
  }

  /// Get order by ID
  Future<Order?> getOrderById(String orderId) async {
    try {
      final response = await _supabase
          .from('orders')
          .select('''
            *,
            order_items(
              *,
              menu_item:menu_items!order_items_menu_item_id_fkey(
                id,
                name,
                image_url
              )
            )
          ''')
          .eq('id', orderId)
          .single();

      return Order.fromJson(response);
    } catch (e) {
      _logger.error('CustomerOrderService: Error fetching order', e);
      return null;
    }
  }

  /// Get customer orders with network error handling
  Future<List<Order>> getCustomerOrders(String customerId, {int limit = 20}) async {
    try {
      _logger.info('CustomerOrderService: Fetching orders for customer: $customerId');

      // Debug: Check current authenticated user
      final currentUser = _supabase.auth.currentUser;
      _logger.info('CustomerOrderService: Current authenticated user: ${currentUser?.id}');
      _logger.info('CustomerOrderService: Current user email: ${currentUser?.email}');

      // Check for network connectivity issues first
      if (!await _isNetworkAvailable()) {
        _logger.warning('CustomerOrderService: Network connectivity issue detected, returning empty list');
        return [];
      }

      final response = await _supabase
          .from('orders')
          .select('''
            *,
            order_items(
              *,
              menu_item:menu_items!order_items_menu_item_id_fkey(
                id,
                name,
                image_url
              )
            )
          ''')
          .eq('customer_id', customerId)
          .order('created_at', ascending: false)
          .limit(limit)
          .timeout(
            const Duration(seconds: 10),
            onTimeout: () {
              _logger.warning('CustomerOrderService: Query timed out after 10 seconds');
              return <Map<String, dynamic>>[];
            },
          );

      _logger.info('CustomerOrderService: Query executed, got ${response.length} orders');
      _logger.info('CustomerOrderService: Raw response: $response');

      final List<Order> orders = [];

      for (final json in response) {
        try {
          // Ensure required fields are not null before parsing
          final orderData = Map<String, dynamic>.from(json);

          // Handle required string fields that might be null
          final requiredStringFields = ['id', 'order_number', 'vendor_id', 'customer_id', 'vendor_name', 'customer_name'];
          for (final field in requiredStringFields) {
            if (orderData[field] == null) {
              _logger.warning('CustomerOrderService: Required field $field is null, setting default');
              orderData[field] = field.contains('name') ? 'Unknown' : '';
            }
          }

          // Ensure order_items is not null and handle empty names
          if (orderData['order_items'] == null) {
            orderData['order_items'] = [];
          } else {
            // Process order_items and extract menu item names from joined data
            final orderItems = orderData['order_items'] as List;
            for (final item in orderItems) {
              if (item is Map<String, dynamic>) {
                // Extract name from joined menu_item data if available
                if (item['menu_item'] != null && item['menu_item'] is Map<String, dynamic>) {
                  final menuItem = item['menu_item'] as Map<String, dynamic>;
                  if (menuItem['name'] != null && (menuItem['name'] as String).isNotEmpty) {
                    item['name'] = menuItem['name'];
                  }
                  // Also extract image_url if available
                  if (menuItem['image_url'] != null) {
                    item['image_url'] = menuItem['image_url'];
                  }
                }

                // Fallback to default name only if still empty after menu_item extraction
                if (item['name'] == null || (item['name'] as String).isEmpty) {
                  item['name'] = 'Menu Item';
                  _logger.warning('CustomerOrderService: Order item name is empty even after menu_item join, setting default name');
                }

                // Ensure other required fields are not null
                if (item['id'] == null) item['id'] = '';
                if (item['menu_item_id'] == null) item['menu_item_id'] = '';
                if (item['unit_price'] == null) item['unit_price'] = 0.0;
                if (item['quantity'] == null) item['quantity'] = 1;
                if (item['total_price'] == null) item['total_price'] = 0.0;
              }
            }
          }

          // Handle delivery_address field
          if (orderData['delivery_address'] is String) {
            try {
              orderData['delivery_address'] = jsonDecode(orderData['delivery_address']);
            } catch (e) {
              orderData['delivery_address'] = {
                'street': 'Unknown',
                'city': 'Unknown',
                'state': 'Unknown',
                'postal_code': '00000',
                'country': 'Malaysia',
              };
            }
          }

          final order = Order.fromJson(orderData);
          orders.add(order);
          _logger.info('CustomerOrderService: Successfully parsed order ${order.orderNumber}');
        } catch (e) {
          _logger.error('CustomerOrderService: Error parsing order: $e');
          // Skip failed orders and continue with the rest
        }
      }

      _logger.info('CustomerOrderService: Successfully parsed ${orders.length} out of ${response.length} orders');
      return orders;
    } catch (e) {
      _logger.error('CustomerOrderService: Error fetching customer orders', e);

      // Check if this is a network-related error
      if (_isNetworkError(e)) {
        _logger.warning('CustomerOrderService: Network error detected, returning empty list as fallback');
        return [];
      }

      // For other errors, still return empty list but log differently
      _logger.error('CustomerOrderService: Non-network error, returning empty list');
      return [];
    }
  }

  /// Check if network is available for Supabase operations
  Future<bool> _isNetworkAvailable() async {
    try {
      // Try a simple DNS lookup to check connectivity
      final result = await InternetAddress.lookup('google.com');
      return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
    } catch (e) {
      _logger.warning('CustomerOrderService: Network availability check failed: $e');
      return false;
    }
  }

  /// Check if an error is network-related
  bool _isNetworkError(dynamic error) {
    final errorString = error.toString().toLowerCase();

    // Network-related error patterns
    final networkErrorPatterns = [
      'socketexception',
      'failed host lookup',
      'no address associated with hostname',
      'connection refused',
      'connection timed out',
      'network is unreachable',
      'no route to host',
      'authretryablefetchexception',
      'clientexception',
    ];

    for (final pattern in networkErrorPatterns) {
      if (errorString.contains(pattern)) {
        _logger.info('CustomerOrderService: Detected network error pattern: $pattern');
        return true;
      }
    }

    return false;
  }
}
