import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../constants/menu_constants.dart';
import '../models/menu_import_data.dart';
import '../models/product.dart';
import '../repositories/menu_item_repository.dart';

/// Service for performing bulk menu import operations
class MenuBulkImportService {
  final SupabaseClient _supabase = Supabase.instance.client;
  final MenuItemRepository _menuItemRepository = MenuItemRepository();

  /// Import menu items from processed import result
  Future<void> importMenuItems(MenuImportResult importResult) async {
    // Get current vendor ID
    final vendorId = await _getCurrentVendorId();
    if (vendorId == null) {
      throw Exception('Vendor not found. Please ensure you are logged in.');
    }

    // Filter only valid rows
    final validRows = importResult.rows.where((row) => row.isValid).toList();
    
    if (validRows.isEmpty) {
      throw Exception('No valid items to import');
    }

    debugPrint('MenuBulkImportService: Starting import of ${validRows.length} items for vendor $vendorId');

    try {
      // Process in batches to avoid overwhelming the database
      const batchSize = 10;
      int processed = 0;
      
      for (int i = 0; i < validRows.length; i += batchSize) {
        final batch = validRows.skip(i).take(batchSize).toList();
        await _processBatch(batch, vendorId);
        processed += batch.length;
        
        debugPrint('MenuBulkImportService: Processed $processed/${validRows.length} items');
      }

      debugPrint('MenuBulkImportService: Successfully imported ${validRows.length} menu items');
    } catch (e) {
      debugPrint('MenuBulkImportService: Import failed: $e');
      rethrow;
    }
  }

  /// Process a batch of import rows
  Future<void> _processBatch(List<MenuImportRow> batch, String vendorId) async {
    for (final row in batch) {
      try {
        await _importSingleItem(row, vendorId);
      } catch (e) {
        debugPrint('MenuBulkImportService: Failed to import item "${row.name}" (row ${row.rowNumber}): $e');
        // Continue with other items even if one fails
      }
    }
  }

  /// Import a single menu item
  Future<void> _importSingleItem(MenuImportRow row, String vendorId) async {
    // Convert import row to Product model
    final product = await _convertToProduct(row, vendorId);
    
    // Create the menu item using existing repository
    await _menuItemRepository.createMenuItem(product);
    
    debugPrint('MenuBulkImportService: Successfully imported "${row.name}"');
  }

  /// Convert import row to Product model
  Future<Product> _convertToProduct(MenuImportRow row, String vendorId) async {
    // Parse allergens
    final allergens = row.allergens?.split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList() ?? [];

    // Parse tags
    final tags = row.tags?.split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList() ?? [];

    // Parse nutritional info
    Map<String, dynamic>? nutritionInfo;
    if (row.nutritionalInfo != null && row.nutritionalInfo!.isNotEmpty) {
      try {
        nutritionInfo = jsonDecode(row.nutritionalInfo!) as Map<String, dynamic>;
      } catch (e) {
        debugPrint('MenuBulkImportService: Failed to parse nutritional info for "${row.name}": $e');
      }
    }

    // Parse customizations
    final customizations = await _parseCustomizations(row.customizationGroups);

    // Create Product instance
    return Product(
      id: '', // Will be generated by database
      vendorId: vendorId,
      name: row.name,
      description: row.description,
      category: row.category,
      tags: tags,
      basePrice: row.basePrice,
      bulkPrice: row.bulkPrice,
      bulkMinQuantity: row.bulkMinQuantity,
      currency: 'MYR',
      includesSst: false, // Default value
      isAvailable: row.isAvailable ?? true,
      minOrderQuantity: row.minOrderQuantity ?? 1,
      maxOrderQuantity: row.maxOrderQuantity,
      preparationTimeMinutes: row.preparationTimeMinutes ?? 30,
      allergens: allergens,
      isHalal: row.isHalal ?? false,
      isVegetarian: row.isVegetarian ?? false,
      isVegan: row.isVegan ?? false,
      isSpicy: row.isSpicy ?? false,
      spicyLevel: row.spicyLevel,
      imageUrl: row.imageUrl,
      galleryImages: [],
      nutritionInfo: nutritionInfo,
      rating: null,
      totalReviews: 0,
      isFeatured: false,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      customizations: customizations,
    );
  }

  /// Parse customization groups from JSON string
  Future<List<MenuItemCustomization>> _parseCustomizations(String? customizationJson) async {
    if (customizationJson == null || customizationJson.isEmpty) {
      return [];
    }

    try {
      final List<dynamic> customizationList = jsonDecode(customizationJson);
      final customizations = <MenuItemCustomization>[];

      for (final customizationData in customizationList) {
        if (customizationData is Map<String, dynamic>) {
          final customization = _parseCustomizationGroup(customizationData);
          if (customization != null) {
            customizations.add(customization);
          }
        }
      }

      return customizations;
    } catch (e) {
      debugPrint('MenuBulkImportService: Failed to parse customizations: $e');
      return [];
    }
  }

  /// Parse a single customization group
  MenuItemCustomization? _parseCustomizationGroup(Map<String, dynamic> data) {
    try {
      final name = data['name'] as String?;
      if (name == null || name.isEmpty) return null;

      final rawType = data['type'] as String? ?? 'single_select';
      // Convert to database-compliant type using the enum
      final type = CustomizationType.fromString(rawType).value;
      final isRequired = data['required'] as bool? ?? false;
      final optionsData = data['options'] as List<dynamic>? ?? [];

      final options = <CustomizationOption>[];
      for (final optionData in optionsData) {
        if (optionData is Map<String, dynamic>) {
          final option = _parseCustomizationOption(optionData);
          if (option != null) {
            options.add(option);
          }
        }
      }

      return MenuItemCustomization(
        name: name,
        type: type,
        isRequired: isRequired,
        options: options,
      );
    } catch (e) {
      debugPrint('MenuBulkImportService: Failed to parse customization group: $e');
      return null;
    }
  }

  /// Parse a single customization option
  CustomizationOption? _parseCustomizationOption(Map<String, dynamic> data) {
    try {
      final name = data['name'] as String?;
      if (name == null || name.isEmpty) return null;

      final price = (data['price'] as num?)?.toDouble() ?? 0.0;

      return CustomizationOption(
        name: name,
        additionalPrice: price,
        isDefault: false, // Default to not default
      );
    } catch (e) {
      debugPrint('MenuBulkImportService: Failed to parse customization option: $e');
      return null;
    }
  }

  /// Get current vendor ID from authenticated user
  Future<String?> _getCurrentVendorId() async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) return null;

      // Query vendor profile for current user
      final response = await _supabase
          .from('vendors')
          .select('id')
          .eq('user_id', user.id)
          .maybeSingle();

      return response?['id'] as String?;
    } catch (e) {
      debugPrint('MenuBulkImportService: Failed to get vendor ID: $e');
      return null;
    }
  }

  /// Validate import data before processing
  Future<List<ImportValidationError>> validateImportData(MenuImportResult importResult) async {
    final errors = <ImportValidationError>[];
    final vendorId = await _getCurrentVendorId();
    
    if (vendorId == null) {
      errors.add(const ImportValidationError(
        type: ImportErrorType.missingRequiredField,
        message: 'Vendor not found. Please ensure you are logged in.',
      ));
      return errors;
    }

    // Get existing menu item names to check for duplicates
    final existingItems = await _getExistingMenuItemNames(vendorId);
    final importNames = <String>{};

    for (final row in importResult.rows) {
      // Check for duplicate names within import
      if (importNames.contains(row.name.toLowerCase())) {
        errors.add(ImportValidationError(
          type: ImportErrorType.duplicateName,
          message: 'Duplicate item name: ${row.name}',
          rowNumber: row.rowNumber,
          suggestedFix: 'Use unique names for each menu item',
        ));
      } else {
        importNames.add(row.name.toLowerCase());
      }

      // Check for duplicate names with existing items
      if (existingItems.contains(row.name.toLowerCase())) {
        errors.add(ImportValidationError(
          type: ImportErrorType.duplicateName,
          message: 'Item name already exists: ${row.name}',
          rowNumber: row.rowNumber,
          suggestedFix: 'Use a different name or update the existing item',
        ));
      }

      // Validate customizations JSON
      if (row.customizationGroups != null && row.customizationGroups!.isNotEmpty) {
        try {
          jsonDecode(row.customizationGroups!);
        } catch (e) {
          errors.add(ImportValidationError(
            type: ImportErrorType.invalidCustomization,
            message: 'Invalid customization JSON format',
            field: 'customizations',
            rowNumber: row.rowNumber,
            suggestedFix: 'Check JSON syntax and structure',
          ));
        }
      }

      // Validate nutritional info JSON
      if (row.nutritionalInfo != null && row.nutritionalInfo!.isNotEmpty) {
        try {
          jsonDecode(row.nutritionalInfo!);
        } catch (e) {
          errors.add(ImportValidationError(
            type: ImportErrorType.invalidValue,
            message: 'Invalid nutritional info JSON format',
            field: 'nutritional_info',
            rowNumber: row.rowNumber,
            suggestedFix: 'Check JSON syntax',
          ));
        }
      }
    }

    return errors;
  }

  /// Get existing menu item names for duplicate checking
  Future<Set<String>> _getExistingMenuItemNames(String vendorId) async {
    try {
      final response = await _supabase
          .from('menu_items')
          .select('name')
          .eq('vendor_id', vendorId);

      return response
          .map((item) => (item['name'] as String).toLowerCase())
          .toSet();
    } catch (e) {
      debugPrint('MenuBulkImportService: Failed to get existing menu items: $e');
      return <String>{};
    }
  }
}
