import 'package:equatable/equatable.dart';
import 'package:json_annotation/json_annotation.dart';

part 'customization_template.g.dart';

/// Represents a reusable customization template that can be applied to multiple menu items
@JsonSerializable()
class CustomizationTemplate extends Equatable {
  final String id;
  @JsonKey(name: 'vendor_id')
  final String vendorId;
  final String name;
  final String? description;
  final String type; // 'single' or 'multiple'
  @JsonKey(name: 'is_required')
  final bool isRequired;
  @JsonKey(name: 'display_order')
  final int displayOrder;
  @JsonKey(name: 'is_active')
  final bool isActive;
  @JsonKey(name: 'usage_count')
  final int usageCount;
  final List<TemplateOption> options;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'updated_at')
  final DateTime updatedAt;

  const CustomizationTemplate({
    required this.id,
    required this.vendorId,
    required this.name,
    this.description,
    this.type = 'single',
    this.isRequired = false,
    this.displayOrder = 0,
    this.isActive = true,
    this.usageCount = 0,
    this.options = const [],
    required this.createdAt,
    required this.updatedAt,
  });

  factory CustomizationTemplate.fromJson(Map<String, dynamic> json) =>
      _$CustomizationTemplateFromJson(json);

  Map<String, dynamic> toJson() => _$CustomizationTemplateToJson(this);

  /// Creates a new template for creation (without ID and timestamps)
  factory CustomizationTemplate.create({
    required String vendorId,
    required String name,
    String? description,
    String type = 'single',
    bool isRequired = false,
    int displayOrder = 0,
    List<TemplateOption> options = const [],
  }) {
    final now = DateTime.now();
    return CustomizationTemplate(
      id: '', // Will be generated by database
      vendorId: vendorId,
      name: name,
      description: description,
      type: type,
      isRequired: isRequired,
      displayOrder: displayOrder,
      options: options,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Creates a test template for testing purposes
  factory CustomizationTemplate.test({
    String? id,
    String? vendorId,
    String? name,
    String? description,
    String? type,
    String? category, // Backward compatibility parameter
    bool? isRequired,
    int? displayOrder,
    bool? isActive,
    int? usageCount,
    List<TemplateOption>? options,
  }) {
    final now = DateTime.now();
    return CustomizationTemplate(
      id: id ?? 'test-template-id',
      vendorId: vendorId ?? 'test-vendor-id',
      name: name ?? 'Test Template',
      description: description ?? 'Test template description',
      type: type ?? 'single',
      isRequired: isRequired ?? false,
      displayOrder: displayOrder ?? 0,
      isActive: isActive ?? true,
      usageCount: usageCount ?? 0,
      options: options ?? [],
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Creates a copy with updated fields
  CustomizationTemplate copyWith({
    String? id,
    String? vendorId,
    String? name,
    String? description,
    String? type,
    bool? isRequired,
    int? displayOrder,
    bool? isActive,
    int? usageCount,
    List<TemplateOption>? options,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return CustomizationTemplate(
      id: id ?? this.id,
      vendorId: vendorId ?? this.vendorId,
      name: name ?? this.name,
      description: description ?? this.description,
      type: type ?? this.type,
      isRequired: isRequired ?? this.isRequired,
      displayOrder: displayOrder ?? this.displayOrder,
      isActive: isActive ?? this.isActive,
      usageCount: usageCount ?? this.usageCount,
      options: options ?? this.options,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Checks if this template is a single selection type (radio buttons)
  bool get isSingleSelection => type == 'single';

  /// Checks if this template is a multiple selection type (checkboxes)
  bool get isMultipleSelection => type == 'multiple';

  /// Gets the default options for this template
  List<TemplateOption> get defaultOptions =>
      options.where((option) => option.isDefault).toList();

  /// Calculates the minimum additional cost for this template
  double get minimumAdditionalCost {
    if (options.isEmpty) return 0.0;
    
    if (isSingleSelection) {
      // For single selection, return the minimum cost among all options
      return options.map((o) => o.additionalPrice).reduce((a, b) => a < b ? a : b);
    } else {
      // For multiple selection, return the minimum cost of default options
      final defaults = defaultOptions;
      if (defaults.isEmpty) return 0.0;
      return defaults.map((o) => o.additionalPrice).reduce((a, b) => a + b);
    }
  }

  /// Calculates the maximum additional cost for this template
  double get maximumAdditionalCost {
    if (options.isEmpty) return 0.0;
    
    if (isSingleSelection) {
      // For single selection, return the maximum cost among all options
      return options.map((o) => o.additionalPrice).reduce((a, b) => a > b ? a : b);
    } else {
      // For multiple selection, return the sum of all option costs
      return options.map((o) => o.additionalPrice).reduce((a, b) => a + b);
    }
  }

  /// Backward compatibility getter for category
  String get category => type;

  /// Backward compatibility getter for allowMultiple
  bool get allowMultiple => isMultipleSelection;

  /// Validates the template configuration
  bool get isValid {
    if (name.trim().isEmpty) return false;
    if (!['single', 'multiple'].contains(type)) return false;
    if (options.isEmpty) return false;

    // Check that at least one option is marked as default for required templates
    if (isRequired && defaultOptions.isEmpty) return false;

    // For single selection, only one option should be default
    if (isSingleSelection && defaultOptions.length > 1) return false;

    return true;
  }

  @override
  List<Object?> get props => [
        id,
        vendorId,
        name,
        description,
        type,
        isRequired,
        displayOrder,
        isActive,
        usageCount,
        options,
        createdAt,
        updatedAt,
      ];
}

/// Represents an option within a customization template
@JsonSerializable()
class TemplateOption extends Equatable {
  final String id;
  @JsonKey(name: 'template_id')
  final String templateId;
  final String name;
  @JsonKey(name: 'additional_price')
  final double additionalPrice;
  @JsonKey(name: 'is_default')
  final bool isDefault;
  @JsonKey(name: 'is_available')
  final bool isAvailable;
  @JsonKey(name: 'display_order')
  final int displayOrder;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'updated_at')
  final DateTime updatedAt;

  const TemplateOption({
    required this.id,
    required this.templateId,
    required this.name,
    this.additionalPrice = 0.0,
    this.isDefault = false,
    this.isAvailable = true,
    this.displayOrder = 0,
    required this.createdAt,
    required this.updatedAt,
  });

  factory TemplateOption.fromJson(Map<String, dynamic> json) =>
      _$TemplateOptionFromJson(json);

  Map<String, dynamic> toJson() => _$TemplateOptionToJson(this);

  /// Creates a new option for creation (without ID and timestamps)
  factory TemplateOption.create({
    required String templateId,
    required String name,
    double additionalPrice = 0.0,
    bool isDefault = false,
    bool isAvailable = true,
    int displayOrder = 0,
  }) {
    final now = DateTime.now();
    return TemplateOption(
      id: '', // Will be generated by database
      templateId: templateId,
      name: name,
      additionalPrice: additionalPrice,
      isDefault: isDefault,
      isAvailable: isAvailable,
      displayOrder: displayOrder,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Creates a test option for testing purposes
  factory TemplateOption.test({
    String? id,
    String? templateId,
    String? name,
    double? price,
    double? additionalPrice,
    bool? isDefault,
    bool? isAvailable,
    int? displayOrder,
  }) {
    final now = DateTime.now();
    return TemplateOption(
      id: id ?? 'test-option-id',
      templateId: templateId ?? 'test-template-id',
      name: name ?? 'Test Option',
      additionalPrice: additionalPrice ?? price ?? 0.0,
      isDefault: isDefault ?? false,
      isAvailable: isAvailable ?? true,
      displayOrder: displayOrder ?? 0,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Creates a copy with updated fields
  TemplateOption copyWith({
    String? id,
    String? templateId,
    String? name,
    double? additionalPrice,
    bool? isDefault,
    bool? isAvailable,
    int? displayOrder,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return TemplateOption(
      id: id ?? this.id,
      templateId: templateId ?? this.templateId,
      name: name ?? this.name,
      additionalPrice: additionalPrice ?? this.additionalPrice,
      isDefault: isDefault ?? this.isDefault,
      isAvailable: isAvailable ?? this.isAvailable,
      displayOrder: displayOrder ?? this.displayOrder,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Backward compatibility getter for price
  double get price => additionalPrice;

  /// Checks if this option has an additional cost
  bool get hasAdditionalCost => additionalPrice > 0;

  /// Validation getter for tests
  bool get isValid => name.trim().isNotEmpty;

  /// Free option checker for tests
  bool get isFree => additionalPrice == 0.0;

  /// Premium option checker for tests
  bool get isPremium => additionalPrice > 10.0;

  /// Gets a formatted price string for display
  String get formattedPrice {
    if (additionalPrice == 0) return 'Free';
    return '+RM ${additionalPrice.toStringAsFixed(2)}';
  }

  @override
  List<Object?> get props => [
        id,
        templateId,
        name,
        additionalPrice,
        isDefault,
        isAvailable,
        displayOrder,
        createdAt,
        updatedAt,
      ];
}

/// Represents the link between a menu item and a customization template
@JsonSerializable()
class MenuItemTemplateLink extends Equatable {
  final String id;
  @JsonKey(name: 'menu_item_id')
  final String menuItemId;
  @JsonKey(name: 'template_id')
  final String templateId;
  @JsonKey(name: 'display_order')
  final int displayOrder;
  @JsonKey(name: 'is_active')
  final bool isActive;
  @JsonKey(name: 'linked_at')
  final DateTime linkedAt;

  const MenuItemTemplateLink({
    required this.id,
    required this.menuItemId,
    required this.templateId,
    this.displayOrder = 0,
    this.isActive = true,
    required this.linkedAt,
  });

  factory MenuItemTemplateLink.fromJson(Map<String, dynamic> json) =>
      _$MenuItemTemplateLinkFromJson(json);

  Map<String, dynamic> toJson() => _$MenuItemTemplateLinkToJson(this);

  /// Creates a new link for creation (without ID and timestamp)
  factory MenuItemTemplateLink.create({
    required String menuItemId,
    required String templateId,
    int displayOrder = 0,
    bool isActive = true,
  }) {
    return MenuItemTemplateLink(
      id: '', // Will be generated by database
      menuItemId: menuItemId,
      templateId: templateId,
      displayOrder: displayOrder,
      isActive: isActive,
      linkedAt: DateTime.now(),
    );
  }

  /// Creates a copy with updated fields
  MenuItemTemplateLink copyWith({
    String? id,
    String? menuItemId,
    String? templateId,
    int? displayOrder,
    bool? isActive,
    DateTime? linkedAt,
  }) {
    return MenuItemTemplateLink(
      id: id ?? this.id,
      menuItemId: menuItemId ?? this.menuItemId,
      templateId: templateId ?? this.templateId,
      displayOrder: displayOrder ?? this.displayOrder,
      isActive: isActive ?? this.isActive,
      linkedAt: linkedAt ?? this.linkedAt,
    );
  }

  @override
  List<Object?> get props => [
        id,
        menuItemId,
        templateId,
        displayOrder,
        isActive,
        linkedAt,
      ];
}
