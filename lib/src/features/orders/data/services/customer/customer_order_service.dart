import 'dart:convert';
import 'dart:io';

import 'package:supabase_flutter/supabase_flutter.dart';
import '../../models/order.dart';
import '../../models/customer_delivery_method.dart';
import '../../../payments/data/services/payment_service.dart';

import '../../../presentation/providers/customer/customer_cart_provider.dart';
import '../../../../core/utils/logger.dart';

/// Customer order service for handling order creation and payment processing
class CustomerOrderService {
  final SupabaseClient _supabase = Supabase.instance.client;
  final PaymentService _paymentService;
  final AppLogger _logger = AppLogger();

  CustomerOrderService({PaymentService? paymentService})
      : _paymentService = paymentService ?? PaymentService();

  /// Create order from customer cart
  Future<Order> createOrderFromCart({
    required CustomerCartState cartState,
    required String paymentMethod,
    String? specialInstructions,
  }) async {
    try {
      _logger.info('CustomerOrderService: Creating order from cart');

      // Validate cart state
      if (cartState.isEmpty) {
        throw Exception('Cart is empty');
      }

      if (cartState.deliveryMethod.requiresDriver && cartState.selectedAddress == null) {
        throw Exception('Delivery address is required for delivery orders');
      }

      // Get current user
      final user = _supabase.auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      // Get customer profile from user metadata
      final customerName = user.userMetadata?['full_name'] ?? user.email ?? 'Customer';
      final customerPhone = user.userMetadata?['phone'] ?? user.phone;

      // Convert cart items to order items
      final orderItems = cartState.items.map((cartItem) => OrderItem(
        id: '', // Will be generated by database
        menuItemId: cartItem.productId,
        name: cartItem.name,
        description: cartItem.description,
        unitPrice: cartItem.unitPrice,
        quantity: cartItem.quantity,
        totalPrice: cartItem.totalPrice,
        customizations: cartItem.customizations,
        notes: cartItem.notes,
      )).toList();

      // Get vendor information from first item
      final firstItem = cartState.items.first;
      final vendorId = firstItem.vendorId;

      // Convert customer address to order address (only if required)
      Address deliveryAddress;
      if (cartState.deliveryMethod.requiresDriver && cartState.selectedAddress != null) {
        final customerAddr = cartState.selectedAddress!;
        deliveryAddress = Address(
          street: customerAddr.addressLine1,
          city: customerAddr.city,
          state: customerAddr.state,
          postalCode: customerAddr.postalCode,
          country: customerAddr.country,
          notes: customerAddr.deliveryInstructions,
        );
      } else {
        // For pickup orders or when no address is selected, use a default address
        deliveryAddress = Address(
          street: 'Pickup Location',
          city: 'N/A',
          state: 'N/A',
          postalCode: '00000',
          country: 'Malaysia',
          notes: 'Customer pickup order',
        );
      }

      // Map customer delivery method to order delivery method
      String deliveryMethodValue = _mapCustomerDeliveryMethodToDatabase(cartState.deliveryMethod);

      // Determine delivery date/time
      DateTime deliveryDateTime;
      if (cartState.deliveryMethod == CustomerDeliveryMethod.scheduled &&
          cartState.scheduledDeliveryTime != null) {
        deliveryDateTime = cartState.scheduledDeliveryTime!;
      } else {
        deliveryDateTime = DateTime.now().add(const Duration(days: 1));
      }

      // Prepare order data for Edge Function
      final orderData = {
        'vendor_id': vendorId,
        'customer_id': user.id,
        'customer_name': customerName,
        'delivery_method': deliveryMethodValue, // Include delivery method
        'delivery_date': deliveryDateTime.toIso8601String(),
        'scheduled_delivery_time': cartState.scheduledDeliveryTime?.toIso8601String(),
        'delivery_address': {
          'street': deliveryAddress.street,
          'city': deliveryAddress.city,
          'state': deliveryAddress.state,
          'postal_code': deliveryAddress.postalCode,
          'country': deliveryAddress.country,
          'notes': deliveryAddress.notes,
        },
        'items': orderItems.map((item) => {
          'menu_item_id': item.menuItemId,
          'quantity': item.quantity,
          'unit_price': item.unitPrice,
          'customizations': item.customizations,
          'notes': item.notes,
        }).toList(),
        'special_instructions': specialInstructions ?? cartState.specialInstructions,
        'contact_phone': customerPhone,
      };

      _logger.info('CustomerOrderService: Calling validate-order-v3 Edge Function');
      _logger.info('CustomerOrderService: Customer ID being sent: ${user.id}');
      _logger.info('CustomerOrderService: Cart delivery method: ${cartState.deliveryMethod}');
      _logger.info('CustomerOrderService: Mapped delivery method: $deliveryMethodValue');
      _logger.info('CustomerOrderService: Order data: $orderData');

      // Create order using Edge Function (using validate-order-v3 which properly handles delivery_method)
      final response = await _supabase.functions.invoke(
        'validate-order-v3',
        body: {'orderData': orderData},
      );

      if (response.status != 200) {
        throw Exception('Failed to create order: HTTP ${response.status}');
      }

      final responseData = response.data;
      if (responseData['success'] != true) {
        final errors = responseData['errors'] as List?;
        final errorMessage = errors?.isNotEmpty == true 
            ? errors!.first.toString() 
            : 'Unknown error occurred';
        throw Exception('Order validation failed: $errorMessage');
      }

      final orderJson = responseData['order'];
      _logger.info('CustomerOrderService: Order created successfully with ID: ${orderJson['id']}');

      // Convert response to Order object
      final order = Order.fromJson(orderJson);
      
      return order;
    } catch (e) {
      _logger.error('CustomerOrderService: Error creating order', e);
      rethrow;
    }
  }

  /// Process payment for an order
  Future<Map<String, dynamic>> processPayment({
    required String orderId,
    required double amount,
    required String paymentMethod,
    String currency = 'myr',
  }) async {
    try {
      _logger.info('CustomerOrderService: Processing payment for order $orderId');

      if (paymentMethod == 'credit_card') {
        // Create payment intent for credit card
        final paymentResult = await _paymentService.createPaymentIntent(
          orderId: orderId,
          amount: amount,
          currency: currency,
        );

        _logger.info('CustomerOrderService: Payment intent created successfully');
        return paymentResult;
      } else if (paymentMethod == 'cash') {
        // For cash on delivery, just update order status
        await _updateOrderPaymentMethod(orderId, 'cash');
        return {
          'success': true,
          'payment_method': 'cash',
          'status': 'pending',
        };
      } else {
        throw Exception('Unsupported payment method: $paymentMethod');
      }
    } catch (e) {
      _logger.error('CustomerOrderService: Error processing payment', e);
      rethrow;
    }
  }

  /// Update order payment method
  Future<void> _updateOrderPaymentMethod(String orderId, String paymentMethod) async {
    try {
      await _supabase
          .from('orders')
          .update({
            'payment_method': paymentMethod,
            'updated_at': DateTime.now().toIso8601String(),
          })
          .eq('id', orderId);

      _logger.info('CustomerOrderService: Updated order payment method to $paymentMethod');
    } catch (e) {
      _logger.error('CustomerOrderService: Error updating order payment method', e);
      rethrow;
    }
  }

  /// Get order by ID
  Future<Order?> getOrderById(String orderId) async {
    try {
      final response = await _supabase
          .from('orders')
          .select('''
            *,
            order_items(
              *,
              menu_item:menu_items!order_items_menu_item_id_fkey(
                id,
                name,
                image_url
              )
            )
          ''')
          .eq('id', orderId)
          .single();

      return Order.fromJson(response);
    } catch (e) {
      _logger.error('CustomerOrderService: Error fetching order', e);
      return null;
    }
  }

  /// Get customer orders with network error handling
  Future<List<Order>> getCustomerOrders(String customerId, {int limit = 50}) async {
    try {
      _logger.info('CustomerOrderService: Fetching orders for customer: $customerId');

      // Debug: Check current authenticated user
      final currentUser = _supabase.auth.currentUser;
      _logger.info('CustomerOrderService: Current authenticated user: ${currentUser?.id}');
      _logger.info('CustomerOrderService: Current user email: ${currentUser?.email}');

      // Check for network connectivity issues first
      if (!await _isNetworkAvailable()) {
        _logger.warning('CustomerOrderService: Network connectivity issue detected, returning empty list');
        return [];
      }

      final response = await _supabase
          .from('orders')
          .select('''
            *,
            vendors!inner(
              id,
              business_name
            )
          ''')
          .eq('customer_id', customerId)
          .order('created_at', ascending: false)
          .limit(limit)
          .timeout(
            const Duration(seconds: 10),
            onTimeout: () {
              _logger.warning('CustomerOrderService: Query timed out after 10 seconds');
              return <Map<String, dynamic>>[];
            },
          );

      _logger.info('CustomerOrderService: Query executed, got ${response.length} orders');
      _logger.info('CustomerOrderService: Raw response: $response');

      final List<Order> orders = [];
      final stopwatch = Stopwatch()..start();
      int successCount = 0;
      int failureCount = 0;

      for (int i = 0; i < response.length; i++) {
        final json = response[i];
        try {
          // Create a copy of the JSON data for processing
          final orderData = Map<String, dynamic>.from(json);

          // Extract vendor name from joined vendor data
          if (orderData['vendor'] != null && orderData['vendor'] is Map<String, dynamic>) {
            final vendor = orderData['vendor'] as Map<String, dynamic>;
            orderData['vendor_name'] = vendor['business_name'] ?? 'Unknown Vendor';
          }

          // Extract customer name from joined customer data if available
          if (orderData['customer'] != null && orderData['customer'] is Map<String, dynamic>) {
            final customer = orderData['customer'] as Map<String, dynamic>;
            orderData['customer_name'] = customer['name'] ?? 'Customer';
          }

          // Process order_items and extract menu item names from joined data
          if (orderData['order_items'] != null && orderData['order_items'] is List) {
            final orderItems = orderData['order_items'] as List;
            for (final item in orderItems) {
              if (item is Map<String, dynamic>) {
                // Extract name from joined menu_item data if available
                if (item['menu_item'] != null && item['menu_item'] is Map<String, dynamic>) {
                  final menuItem = item['menu_item'] as Map<String, dynamic>;
                  if (menuItem['name'] != null) {
                    item['name'] = menuItem['name'];
                  }
                  if (menuItem['description'] != null) {
                    item['description'] = menuItem['description'];
                  }
                  if (menuItem['image_url'] != null) {
                    item['image_url'] = menuItem['image_url'];
                  }
                }
              }
            }
          }

          // Handle delivery_address field - parse JSON string if needed
          if (orderData['delivery_address'] is String) {
            try {
              orderData['delivery_address'] = jsonDecode(orderData['delivery_address']);
            } catch (e) {
              _logger.warning('CustomerOrderService: Failed to parse delivery_address JSON for order ${i + 1}: $e');
              // Order model will handle null/invalid address with defaults
              orderData['delivery_address'] = null;
            }
          }

          final order = Order.fromJson(orderData);
          orders.add(order);
          successCount++;
          _logger.info('CustomerOrderService: Successfully parsed order ${order.orderNumber}');
        } catch (e, stackTrace) {
          failureCount++;
          final orderId = json['id']?.toString() ?? 'unknown';
          final orderNumber = json['order_number']?.toString() ?? 'unknown';

          _logger.error(
            'CustomerOrderService: Failed to parse order $orderId ($orderNumber) at index ${i + 1}: $e',
            e,
            stackTrace,
          );

          // Log specific error types for debugging
          if (e.toString().contains('type \'Null\' is not a subtype')) {
            _logger.error('CustomerOrderService: Null casting error detected - this should not happen with updated Order model');
          } else if (e.toString().contains('FormatException')) {
            _logger.error('CustomerOrderService: Data format error - check database schema');
          } else if (e.toString().contains('TypeError')) {
            _logger.error('CustomerOrderService: Type error - check field types in database vs model');
          }

          // Continue processing other orders
        }
      }

      stopwatch.stop();
      final processingTime = stopwatch.elapsedMilliseconds;

      _logger.info(
        'CustomerOrderService: Order parsing completed - '
        'Success: $successCount, Failed: $failureCount, Total: ${response.length}, '
        'Processing time: ${processingTime}ms'
      );

      if (failureCount > 0) {
        _logger.warning(
          'CustomerOrderService: $failureCount orders failed to parse. '
          'Check logs above for specific error details.'
        );
      }

      return orders;
    } catch (e, stackTrace) {
      _logger.error('CustomerOrderService: Error fetching customer orders', e, stackTrace);

      // Provide more specific error handling based on error type
      if (_isNetworkError(e)) {
        _logger.warning('CustomerOrderService: Network error detected - check internet connection');
      } else if (e.toString().contains('PostgrestException')) {
        _logger.error('CustomerOrderService: Database query error - check RLS policies and table structure');
      } else if (e.toString().contains('AuthException')) {
        _logger.error('CustomerOrderService: Authentication error - user may need to re-login');
      } else {
        _logger.error('CustomerOrderService: Unexpected error type: ${e.runtimeType}');
      }

      // Always return empty list as fallback to prevent app crashes
      _logger.info('CustomerOrderService: Returning empty list as fallback');
      return [];
    }
  }

  /// Check if network is available for Supabase operations
  Future<bool> _isNetworkAvailable() async {
    try {
      // Try a simple DNS lookup to check connectivity
      final result = await InternetAddress.lookup('google.com');
      return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
    } catch (e) {
      _logger.warning('CustomerOrderService: Network availability check failed: $e');
      return false;
    }
  }

  /// Check if an error is network-related
  bool _isNetworkError(dynamic error) {
    final errorString = error.toString().toLowerCase();

    // Network-related error patterns
    final networkErrorPatterns = [
      'socketexception',
      'failed host lookup',
      'no address associated with hostname',
      'connection refused',
      'connection timed out',
      'network is unreachable',
      'no route to host',
      'authretryablefetchexception',
      'clientexception',
    ];

    for (final pattern in networkErrorPatterns) {
      if (errorString.contains(pattern)) {
        _logger.info('CustomerOrderService: Detected network error pattern: $pattern');
        return true;
      }
    }

    return false;
  }

  /// Map CustomerDeliveryMethod to database-compatible delivery method string
  String _mapCustomerDeliveryMethodToDatabase(CustomerDeliveryMethod method) {
    _logger.info('CustomerOrderService: Mapping delivery method: $method');

    String result;
    switch (method) {
      case CustomerDeliveryMethod.customerPickup:
      case CustomerDeliveryMethod.pickup:
        result = 'customer_pickup';
        break;
      case CustomerDeliveryMethod.salesAgentPickup:
        result = 'sales_agent_pickup';
        break;
      case CustomerDeliveryMethod.ownFleet:
      case CustomerDeliveryMethod.delivery:
        result = 'own_fleet';
        break;
      case CustomerDeliveryMethod.lalamove:
      case CustomerDeliveryMethod.thirdParty:
        result = 'lalamove';
        break;
      case CustomerDeliveryMethod.scheduled:
        // For scheduled delivery, default to own fleet
        result = 'own_fleet';
        break;
    }

    _logger.info('CustomerOrderService: Mapped $method to $result');
    return result;
  }
}
