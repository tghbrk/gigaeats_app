import 'dart:convert';
import 'dart:io';

import 'package:supabase_flutter/supabase_flutter.dart';
import '../../models/order.dart';
import '../../models/customer_delivery_method.dart';
import '../../../payments/data/services/payment_service.dart';
import '../../../../marketplace_wallet/integration/wallet_checkout_integration_service.dart';

import '../../../presentation/providers/customer/customer_cart_provider.dart';
import '../../../../core/utils/logger.dart';

/// Customer order service for handling order creation and payment processing
class CustomerOrderService {
  final SupabaseClient _supabase = Supabase.instance.client;
  final PaymentService _paymentService;
  final WalletCheckoutIntegrationService? _walletCheckoutService;
  final AppLogger _logger = AppLogger();

  CustomerOrderService({
    PaymentService? paymentService,
    WalletCheckoutIntegrationService? walletCheckoutService,
  }) : _paymentService = paymentService ?? PaymentService(),
       _walletCheckoutService = walletCheckoutService;

  /// Create order from customer cart
  Future<Order> createOrderFromCart({
    required CustomerCartState cartState,
    required String paymentMethod,
    String? specialInstructions,
  }) async {
    try {
      _logger.info('CustomerOrderService: Creating order from cart');

      // Validate cart state
      if (cartState.isEmpty) {
        throw Exception('Cart is empty');
      }

      if (cartState.deliveryMethod.requiresDriver && cartState.selectedAddress == null) {
        throw Exception('Delivery address is required for delivery orders');
      }

      // Get current user
      final user = _supabase.auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      // Get customer profile from user metadata
      final customerName = user.userMetadata?['full_name'] ?? user.email ?? 'Customer';
      final customerPhone = user.userMetadata?['phone'] ?? user.phone;

      // Convert cart items to order items
      final orderItems = cartState.items.map((cartItem) => OrderItem(
        id: '', // Will be generated by database
        menuItemId: cartItem.productId,
        name: cartItem.name,
        description: cartItem.description,
        unitPrice: cartItem.unitPrice,
        quantity: cartItem.quantity,
        totalPrice: cartItem.totalPrice,
        customizations: cartItem.customizations,
        notes: cartItem.notes,
      )).toList();

      // Get vendor information from first item
      final firstItem = cartState.items.first;
      final vendorId = firstItem.vendorId;

      // Convert customer address to order address (only if required)
      Address deliveryAddress;
      if (cartState.deliveryMethod.requiresDriver && cartState.selectedAddress != null) {
        final customerAddr = cartState.selectedAddress!;
        deliveryAddress = Address(
          street: customerAddr.addressLine1,
          city: customerAddr.city,
          state: customerAddr.state,
          postalCode: customerAddr.postalCode,
          country: customerAddr.country,
          notes: customerAddr.deliveryInstructions,
        );
      } else {
        // For pickup orders or when no address is selected, use a default address
        deliveryAddress = Address(
          street: 'Pickup Location',
          city: 'N/A',
          state: 'N/A',
          postalCode: '00000',
          country: 'Malaysia',
          notes: 'Customer pickup order',
        );
      }

      // Map customer delivery method to order delivery method
      String deliveryMethodValue = _mapCustomerDeliveryMethodToDatabase(cartState.deliveryMethod);

      // Determine delivery date/time
      DateTime deliveryDateTime;
      if (cartState.deliveryMethod == CustomerDeliveryMethod.scheduled &&
          cartState.scheduledDeliveryTime != null) {
        deliveryDateTime = cartState.scheduledDeliveryTime!;
      } else {
        deliveryDateTime = DateTime.now().add(const Duration(days: 1));
      }

      // Prepare order data for Edge Function
      final orderData = {
        'vendor_id': vendorId,
        'customer_id': user.id,
        'customer_name': customerName,
        'delivery_method': deliveryMethodValue, // Include delivery method
        'delivery_date': deliveryDateTime.toIso8601String(),
        'scheduled_delivery_time': cartState.scheduledDeliveryTime?.toIso8601String(),
        'delivery_address': {
          'street': deliveryAddress.street,
          'city': deliveryAddress.city,
          'state': deliveryAddress.state,
          'postal_code': deliveryAddress.postalCode,
          'country': deliveryAddress.country,
          'notes': deliveryAddress.notes,
        },
        'items': orderItems.map((item) => {
          'menu_item_id': item.menuItemId,
          'quantity': item.quantity,
          'unit_price': item.unitPrice,
          'customizations': item.customizations,
          'notes': item.notes,
        }).toList(),
        'special_instructions': specialInstructions ?? cartState.specialInstructions,
        'contact_phone': customerPhone,
      };

      _logger.info('CustomerOrderService: Calling validate-order-v3 Edge Function');
      _logger.info('CustomerOrderService: Customer ID being sent: ${user.id}');
      _logger.info('CustomerOrderService: Cart delivery method: ${cartState.deliveryMethod}');
      _logger.info('CustomerOrderService: Mapped delivery method: $deliveryMethodValue');
      _logger.info('CustomerOrderService: Order data: $orderData');

      // Create order using Edge Function (using validate-order-v3 which properly handles delivery_method)
      final response = await _supabase.functions.invoke(
        'validate-order-v3',
        body: {'orderData': orderData},
      );

      if (response.status != 200) {
        throw Exception('Failed to create order: HTTP ${response.status}');
      }

      final responseData = response.data;
      if (responseData['success'] != true) {
        final errors = responseData['errors'] as List?;
        final errorMessage = errors?.isNotEmpty == true 
            ? errors!.first.toString() 
            : 'Unknown error occurred';
        throw Exception('Order validation failed: $errorMessage');
      }

      final orderJson = responseData['order'];
      _logger.info('CustomerOrderService: Order created successfully with ID: ${orderJson['id']}');

      // Convert response to Order object
      final order = Order.fromJson(orderJson);
      
      return order;
    } catch (e) {
      _logger.error('CustomerOrderService: Error creating order', e);
      rethrow;
    }
  }

  /// Process payment for an order
  Future<Map<String, dynamic>> processPayment({
    required String orderId,
    required double amount,
    required String paymentMethod,
    String currency = 'myr',
  }) async {
    try {
      _logger.info('CustomerOrderService: Processing payment for order $orderId');

      if (paymentMethod == 'credit_card') {
        // Create payment intent for credit card
        final paymentResult = await _paymentService.createPaymentIntent(
          orderId: orderId,
          amount: amount,
          currency: currency,
        );

        _logger.info('CustomerOrderService: Payment intent created successfully');
        return paymentResult;
      } else if (paymentMethod == 'cash') {
        // For cash on delivery, just update order status
        await _updateOrderPaymentMethod(orderId, 'cash');
        return {
          'success': true,
          'payment_method': 'cash',
          'status': 'pending',
        };
      } else if (paymentMethod == 'wallet') {
        // SECURITY FIX: Process wallet payment via secure Edge Function
        return await _processWalletPayment(
          orderId: orderId,
          amount: amount,
          currency: currency,
        );
      } else {
        throw Exception('Unsupported payment method: $paymentMethod');
      }
    } catch (e) {
      _logger.error('CustomerOrderService: Error processing payment', e);
      rethrow;
    }
  }

  /// Update order payment method
  Future<void> _updateOrderPaymentMethod(String orderId, String paymentMethod) async {
    try {
      await _supabase
          .from('orders')
          .update({
            'payment_method': paymentMethod,
            'updated_at': DateTime.now().toIso8601String(),
          })
          .eq('id', orderId);

      _logger.info('CustomerOrderService: Updated order payment method to $paymentMethod');
    } catch (e) {
      _logger.error('CustomerOrderService: Error updating order payment method', e);
      rethrow;
    }
  }

  /// SECURITY FIX: Process wallet payment with comprehensive validation and error handling
  Future<Map<String, dynamic>> _processWalletPayment({
    required String orderId,
    required double amount,
    required String currency,
  }) async {
    try {
      _logger.info('CustomerOrderService: Processing wallet payment for order $orderId');
      _logger.info('CustomerOrderService: Amount: $amount $currency');

      // Step 1: Pre-validation checks
      final preValidationResult = await _preValidateWalletPayment(orderId, amount, currency);
      if (!preValidationResult['success']) {
        return preValidationResult;
      }

      final order = preValidationResult['order'] as Order;

      _logger.info('CustomerOrderService: Pre-validation passed, initiating secure wallet payment via Edge Function');

      // Step 2: Additional security validation
      final securityValidationResult = await _performSecurityValidation(order, amount);
      if (!securityValidationResult['success']) {
        return securityValidationResult;
      }

      // Process wallet payment via secure Edge Function
      final response = await _supabase.functions.invoke(
        'secure-wallet-operations',
        body: {
          'action': 'process_order_payment',
          'wallet_id': null, // Will be resolved by Edge Function based on user
          'order_id': orderId,
          'transaction_data': {
            'amount': amount,
            'currency': currency.toUpperCase(),
            'description': 'Payment for order ${order.orderNumber}',
            'metadata': {
              'order_number': order.orderNumber,
              'vendor_id': order.vendorId,
              'payment_method': 'wallet',
              'processed_by': 'customer_order_service',
              'processed_at': DateTime.now().toIso8601String(),
            },
          },
        },
      );

      if (response.status != 200) {
        throw Exception('Wallet payment failed: HTTP ${response.status}');
      }

      final result = response.data;
      if (result['success'] != true) {
        throw Exception(result['message'] ?? 'Wallet payment failed');
      }

      _logger.info('CustomerOrderService: Wallet payment successful');
      _logger.info('CustomerOrderService: Transaction ID: ${result['transaction_id']}');
      _logger.info('CustomerOrderService: New wallet balance: RM ${result['new_balance']?.toStringAsFixed(2)}');

      // Update order payment method
      await _updateOrderPaymentMethod(orderId, 'wallet');

      return {
        'success': true,
        'payment_method': 'wallet',
        'status': 'paid',
        'transaction_id': result['transaction_id'],
        'amount_paid': result['amount_paid'],
        'new_wallet_balance': result['new_balance'],
        'message': 'Wallet payment processed successfully',
      };

    } catch (e) {
      _logger.error('CustomerOrderService: Wallet payment failed', e);

      // Comprehensive error handling with categorization
      final errorResult = _categorizeWalletPaymentError(e, orderId);

      // Log error details for debugging
      _logger.error('CustomerOrderService: Error category: ${errorResult['error_code']}');
      _logger.error('CustomerOrderService: User message: ${errorResult['error']}');

      // Attempt rollback if order was created but payment failed
      await _handlePaymentFailureRollback(orderId, errorResult['error_code']);

      return errorResult;
    }
  }

  /// Pre-validate wallet payment before processing
  Future<Map<String, dynamic>> _preValidateWalletPayment(
    String orderId,
    double amount,
    String currency,
  ) async {
    try {
      _logger.info('CustomerOrderService: Pre-validating wallet payment');

      // Validate wallet checkout service is available
      if (_walletCheckoutService == null) {
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Wallet service temporarily unavailable. Please try again later or contact support.',
          'error_code': 'SERVICE_UNAVAILABLE',
        };
      }

      // Validate user authentication
      final user = _supabase.auth.currentUser;
      if (user == null) {
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Please log in to complete your payment.',
          'error_code': 'USER_NOT_AUTHENTICATED',
        };
      }

      // Validate order exists and belongs to user
      final order = await getOrderById(orderId);
      if (order == null) {
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Order not found. Please try placing your order again.',
          'error_code': 'ORDER_NOT_FOUND',
        };
      }

      // Validate order ownership
      if (order.customerId != user.id) {
        _logger.warning('CustomerOrderService: Unauthorized order access attempt - Order: ${order.customerId}, User: ${user.id}');
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'You are not authorized to pay for this order.',
          'error_code': 'UNAUTHORIZED_ORDER_ACCESS',
        };
      }

      // Validate order status
      if (order.status != OrderStatus.pending) {
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'This order cannot be paid for. Current status: ${order.status.name}',
          'error_code': 'INVALID_ORDER_STATUS',
        };
      }

      // Validate payment amount matches order total
      if ((order.totalAmount - amount).abs() > 0.01) {
        _logger.warning('CustomerOrderService: Payment amount mismatch - Order: ${order.totalAmount}, Payment: $amount');
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Payment amount does not match order total. Please refresh and try again.',
          'error_code': 'AMOUNT_MISMATCH',
        };
      }

      // Validate currency
      if (currency.toLowerCase() != 'myr') {
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Invalid currency. Only MYR is supported.',
          'error_code': 'INVALID_CURRENCY',
        };
      }

      // Validate minimum payment amount
      if (amount < 0.01) {
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Payment amount must be at least RM 0.01.',
          'error_code': 'AMOUNT_TOO_LOW',
        };
      }

      // Validate maximum payment amount (security check)
      if (amount > 10000.00) {
        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Payment amount exceeds maximum limit. Please contact support for large orders.',
          'error_code': 'AMOUNT_TOO_HIGH',
        };
      }

      _logger.info('CustomerOrderService: Pre-validation successful');
      return {
        'success': true,
        'order': order,
        'user': user,
      };

    } catch (e) {
      _logger.error('CustomerOrderService: Pre-validation failed', e);
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Payment validation failed. Please try again.',
        'error_code': 'VALIDATION_ERROR',
      };
    }
  }

  /// Categorize wallet payment errors for better user experience
  Map<String, dynamic> _categorizeWalletPaymentError(dynamic error, String orderId) {
    final errorString = error.toString().toLowerCase();

    // Network and connectivity errors
    if (errorString.contains('network') || errorString.contains('connection') ||
        errorString.contains('timeout') || errorString.contains('unreachable')) {
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Network connection issue. Please check your internet connection and try again.',
        'error_code': 'NETWORK_ERROR',
        'retry_allowed': true,
      };
    }

    // Insufficient balance errors
    if (errorString.contains('insufficient') || errorString.contains('balance')) {
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Insufficient wallet balance. Please top up your wallet or use a different payment method.',
        'error_code': 'INSUFFICIENT_BALANCE',
        'retry_allowed': false,
      };
    }

    // Authentication and authorization errors
    if (errorString.contains('unauthorized') || errorString.contains('access denied') ||
        errorString.contains('permission')) {
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Wallet access denied. Please log out and log back in, then try again.',
        'error_code': 'UNAUTHORIZED_ACCESS',
        'retry_allowed': false,
      };
    }

    // Wallet not found or unavailable
    if (errorString.contains('wallet not found') || errorString.contains('wallet unavailable')) {
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Wallet not found. Please set up your wallet first.',
        'error_code': 'WALLET_NOT_FOUND',
        'retry_allowed': false,
      };
    }

    // Order-related errors
    if (errorString.contains('order not found') || errorString.contains('order') && errorString.contains('not found')) {
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Order not found. Please try placing your order again.',
        'error_code': 'ORDER_NOT_FOUND',
        'retry_allowed': false,
      };
    }

    // Server errors (HTTP 500, etc.)
    if (errorString.contains('http 5') || errorString.contains('server error') ||
        errorString.contains('internal error')) {
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Server temporarily unavailable. Please try again in a few moments.',
        'error_code': 'SERVER_ERROR',
        'retry_allowed': true,
      };
    }

    // Rate limiting errors
    if (errorString.contains('rate limit') || errorString.contains('too many requests')) {
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Too many payment attempts. Please wait a moment and try again.',
        'error_code': 'RATE_LIMITED',
        'retry_allowed': true,
      };
    }

    // Validation errors
    if (errorString.contains('validation') || errorString.contains('invalid')) {
      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Payment information is invalid. Please refresh the page and try again.',
        'error_code': 'VALIDATION_ERROR',
        'retry_allowed': true,
      };
    }

    // Generic/unknown errors
    return {
      'success': false,
      'payment_method': 'wallet',
      'status': 'failed',
      'error': 'Payment failed due to an unexpected error. Please try again or contact support.',
      'error_code': 'UNKNOWN_ERROR',
      'retry_allowed': true,
    };
  }

  /// Handle payment failure rollback
  Future<void> _handlePaymentFailureRollback(String orderId, String errorCode) async {
    try {
      _logger.info('CustomerOrderService: Handling payment failure rollback for order $orderId');

      // For certain error types, we should mark the order as payment_failed
      // rather than leaving it in pending state
      final shouldMarkAsFailed = [
        'INSUFFICIENT_BALANCE',
        'UNAUTHORIZED_ACCESS',
        'WALLET_NOT_FOUND',
        'VALIDATION_ERROR',
      ].contains(errorCode);

      if (shouldMarkAsFailed) {
        await _supabase
            .from('orders')
            .update({
              'payment_status': 'failed',
              'payment_failure_reason': errorCode,
              'updated_at': DateTime.now().toIso8601String(),
            })
            .eq('id', orderId);

        _logger.info('CustomerOrderService: Order $orderId marked as payment failed');
      } else {
        // For transient errors (network, server), keep order in pending state
        // so user can retry payment
        _logger.info('CustomerOrderService: Order $orderId kept in pending state for retry');
      }

    } catch (e) {
      _logger.error('CustomerOrderService: Failed to handle payment rollback', e);
      // Don't throw here - we don't want rollback failures to mask the original error
    }
  }

  /// Perform additional security validation for wallet payments
  Future<Map<String, dynamic>> _performSecurityValidation(Order order, double amount) async {
    try {
      _logger.info('CustomerOrderService: Performing additional security validation');

      final user = _supabase.auth.currentUser!;

      // Security Check 1: Rate limiting - check recent payment attempts
      final recentAttempts = await _checkRecentPaymentAttempts(user.id);
      if (recentAttempts >= 5) {
        await _logSecurityEvent('RATE_LIMIT_EXCEEDED', user.id, {
          'order_id': order.id,
          'recent_attempts': recentAttempts,
          'amount': amount,
        });

        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Too many payment attempts. Please wait 5 minutes before trying again.',
          'error_code': 'RATE_LIMITED',
          'retry_allowed': false,
        };
      }

      // Security Check 2: Validate order creation time (prevent replay attacks)
      final orderAge = DateTime.now().difference(order.createdAt);
      if (orderAge.inMinutes > 30) {
        await _logSecurityEvent('STALE_ORDER_PAYMENT', user.id, {
          'order_id': order.id,
          'order_age_minutes': orderAge.inMinutes,
          'amount': amount,
        });

        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Order is too old to process payment. Please create a new order.',
          'error_code': 'STALE_ORDER',
          'retry_allowed': false,
        };
      }

      // Security Check 3: Validate user session freshness
      final sessionAge = await _getSessionAge();
      if (sessionAge != null && sessionAge.inHours > 24) {
        await _logSecurityEvent('STALE_SESSION_PAYMENT', user.id, {
          'order_id': order.id,
          'session_age_hours': sessionAge.inHours,
          'amount': amount,
        });

        return {
          'success': false,
          'payment_method': 'wallet',
          'status': 'failed',
          'error': 'Your session has expired. Please log out and log back in.',
          'error_code': 'SESSION_EXPIRED',
          'retry_allowed': false,
        };
      }

      // Security Check 4: Validate large transaction patterns
      if (amount > 500.00) {
        final isLargeTransactionAllowed = await _validateLargeTransaction(user.id, amount);
        if (!isLargeTransactionAllowed) {
          await _logSecurityEvent('LARGE_TRANSACTION_BLOCKED', user.id, {
            'order_id': order.id,
            'amount': amount,
            'threshold': 500.00,
          });

          return {
            'success': false,
            'payment_method': 'wallet',
            'status': 'failed',
            'error': 'Large transactions require additional verification. Please contact support.',
            'error_code': 'LARGE_TRANSACTION_BLOCKED',
            'retry_allowed': false,
          };
        }
      }

      // Security Check 5: Validate wallet balance freshness
      final walletBalanceAge = await _getWalletBalanceAge(user.id);
      if (walletBalanceAge != null && walletBalanceAge.inMinutes > 10) {
        // Force wallet balance refresh for security
        await _refreshWalletBalance(user.id);
      }

      // Log successful security validation
      await _logSecurityEvent('SECURITY_VALIDATION_PASSED', user.id, {
        'order_id': order.id,
        'amount': amount,
        'validation_checks': [
          'rate_limiting',
          'order_age',
          'session_freshness',
          'large_transaction',
          'wallet_balance_freshness',
        ],
      });

      _logger.info('CustomerOrderService: Security validation passed');
      return {'success': true};

    } catch (e) {
      _logger.error('CustomerOrderService: Security validation failed', e);

      await _logSecurityEvent('SECURITY_VALIDATION_ERROR',
        _supabase.auth.currentUser?.id ?? 'unknown', {
        'order_id': order.id,
        'amount': amount,
        'error': e.toString(),
      });

      return {
        'success': false,
        'payment_method': 'wallet',
        'status': 'failed',
        'error': 'Security validation failed. Please try again.',
        'error_code': 'SECURITY_VALIDATION_ERROR',
        'retry_allowed': true,
      };
    }
  }

  /// Check recent payment attempts for rate limiting
  Future<int> _checkRecentPaymentAttempts(String userId) async {
    try {
      final fiveMinutesAgo = DateTime.now().subtract(const Duration(minutes: 5));

      final response = await _supabase
          .from('payment_attempts')
          .select('id')
          .eq('user_id', userId)
          .gte('created_at', fiveMinutesAgo.toIso8601String())
          .count();

      return response.count;
    } catch (e) {
      _logger.warning('CustomerOrderService: Failed to check recent payment attempts', e);
      return 0; // Fail open for availability
    }
  }

  /// Get session age for security validation
  Future<Duration?> _getSessionAge() async {
    try {
      final session = _supabase.auth.currentSession;
      if (session?.accessToken != null) {
        // For security purposes, we'll check if the session is older than 24 hours
        // by checking the last authentication time from the user metadata
        final user = _supabase.auth.currentUser;
        if (user?.lastSignInAt != null) {
          final lastSignIn = DateTime.parse(user!.lastSignInAt!);
          return DateTime.now().difference(lastSignIn);
        }
      }
      return null;
    } catch (e) {
      _logger.warning('CustomerOrderService: Failed to get session age', e);
      return null;
    }
  }

  /// Validate large transaction patterns
  Future<bool> _validateLargeTransaction(String userId, double amount) async {
    try {
      // Check user's transaction history for large transactions
      final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));

      final response = await _supabase
          .from('wallet_transactions')
          .select('amount')
          .eq('user_id', userId)
          .gte('created_at', thirtyDaysAgo.toIso8601String())
          .gte('amount', 500.0)
          .count();

      final largeTransactionCount = response.count;

      // Allow if user has history of large transactions
      return largeTransactionCount > 0;
    } catch (e) {
      _logger.warning('CustomerOrderService: Failed to validate large transaction', e);
      return false; // Fail secure for large transactions
    }
  }

  /// Get wallet balance age for freshness validation
  Future<Duration?> _getWalletBalanceAge(String userId) async {
    try {
      final response = await _supabase
          .from('stakeholder_wallets')
          .select('last_activity_at')
          .eq('user_id', userId)
          .single();

      if (response['last_activity_at'] != null) {
        final lastActivity = DateTime.parse(response['last_activity_at']);
        return DateTime.now().difference(lastActivity);
      }
      return null;
    } catch (e) {
      _logger.warning('CustomerOrderService: Failed to get wallet balance age', e);
      return null;
    }
  }

  /// Refresh wallet balance for security
  Future<void> _refreshWalletBalance(String userId) async {
    try {
      await _supabase
          .from('stakeholder_wallets')
          .update({
            'last_activity_at': DateTime.now().toIso8601String(),
          })
          .eq('user_id', userId);
    } catch (e) {
      _logger.warning('CustomerOrderService: Failed to refresh wallet balance', e);
    }
  }

  /// Log security events for audit trail
  Future<void> _logSecurityEvent(String eventType, String userId, Map<String, dynamic> eventData) async {
    try {
      await _supabase
          .from('security_audit_log')
          .insert({
            'event_type': eventType,
            'user_id': userId,
            'event_data': eventData,
            'ip_address': null, // Would be populated by Edge Function
            'user_agent': null, // Would be populated by Edge Function
            'created_at': DateTime.now().toIso8601String(),
          });

      _logger.info('CustomerOrderService: Security event logged: $eventType');
    } catch (e) {
      _logger.error('CustomerOrderService: Failed to log security event', e);
      // Don't throw - logging failures shouldn't break payment flow
    }
  }

  /// Get order by ID
  Future<Order?> getOrderById(String orderId) async {
    try {
      final response = await _supabase
          .from('orders')
          .select('''
            *,
            order_items(
              *,
              menu_item:menu_items!order_items_menu_item_id_fkey(
                id,
                name,
                image_url
              )
            )
          ''')
          .eq('id', orderId)
          .single();

      return Order.fromJson(response);
    } catch (e) {
      _logger.error('CustomerOrderService: Error fetching order', e);
      return null;
    }
  }

  /// Get customer orders with network error handling
  Future<List<Order>> getCustomerOrders(String customerId, {int limit = 50}) async {
    try {
      _logger.info('CustomerOrderService: Fetching orders for customer: $customerId');

      // Debug: Check current authenticated user
      final currentUser = _supabase.auth.currentUser;
      _logger.info('CustomerOrderService: Current authenticated user: ${currentUser?.id}');
      _logger.info('CustomerOrderService: Current user email: ${currentUser?.email}');

      // Check for network connectivity issues first
      if (!await _isNetworkAvailable()) {
        _logger.warning('CustomerOrderService: Network connectivity issue detected, returning empty list');
        return [];
      }

      final response = await _supabase
          .from('orders')
          .select('''
            *,
            vendors!inner(
              id,
              business_name
            )
          ''')
          .eq('customer_id', customerId)
          .order('created_at', ascending: false)
          .limit(limit)
          .timeout(
            const Duration(seconds: 10),
            onTimeout: () {
              _logger.warning('CustomerOrderService: Query timed out after 10 seconds');
              return <Map<String, dynamic>>[];
            },
          );

      _logger.info('CustomerOrderService: Query executed, got ${response.length} orders');
      _logger.info('CustomerOrderService: Raw response: $response');

      final List<Order> orders = [];
      final stopwatch = Stopwatch()..start();
      int successCount = 0;
      int failureCount = 0;

      for (int i = 0; i < response.length; i++) {
        final json = response[i];
        try {
          // Create a copy of the JSON data for processing
          final orderData = Map<String, dynamic>.from(json);

          // Extract vendor name from joined vendor data
          if (orderData['vendor'] != null && orderData['vendor'] is Map<String, dynamic>) {
            final vendor = orderData['vendor'] as Map<String, dynamic>;
            orderData['vendor_name'] = vendor['business_name'] ?? 'Unknown Vendor';
          }

          // Extract customer name from joined customer data if available
          if (orderData['customer'] != null && orderData['customer'] is Map<String, dynamic>) {
            final customer = orderData['customer'] as Map<String, dynamic>;
            orderData['customer_name'] = customer['name'] ?? 'Customer';
          }

          // Process order_items and extract menu item names from joined data
          if (orderData['order_items'] != null && orderData['order_items'] is List) {
            final orderItems = orderData['order_items'] as List;
            for (final item in orderItems) {
              if (item is Map<String, dynamic>) {
                // Extract name from joined menu_item data if available
                if (item['menu_item'] != null && item['menu_item'] is Map<String, dynamic>) {
                  final menuItem = item['menu_item'] as Map<String, dynamic>;
                  if (menuItem['name'] != null) {
                    item['name'] = menuItem['name'];
                  }
                  if (menuItem['description'] != null) {
                    item['description'] = menuItem['description'];
                  }
                  if (menuItem['image_url'] != null) {
                    item['image_url'] = menuItem['image_url'];
                  }
                }
              }
            }
          }

          // Handle delivery_address field - parse JSON string if needed
          if (orderData['delivery_address'] is String) {
            try {
              orderData['delivery_address'] = jsonDecode(orderData['delivery_address']);
            } catch (e) {
              _logger.warning('CustomerOrderService: Failed to parse delivery_address JSON for order ${i + 1}: $e');
              // Order model will handle null/invalid address with defaults
              orderData['delivery_address'] = null;
            }
          }

          final order = Order.fromJson(orderData);
          orders.add(order);
          successCount++;
          _logger.info('CustomerOrderService: Successfully parsed order ${order.orderNumber}');
        } catch (e, stackTrace) {
          failureCount++;
          final orderId = json['id']?.toString() ?? 'unknown';
          final orderNumber = json['order_number']?.toString() ?? 'unknown';

          _logger.error(
            'CustomerOrderService: Failed to parse order $orderId ($orderNumber) at index ${i + 1}: $e',
            e,
            stackTrace,
          );

          // Log specific error types for debugging
          if (e.toString().contains('type \'Null\' is not a subtype')) {
            _logger.error('CustomerOrderService: Null casting error detected - this should not happen with updated Order model');
          } else if (e.toString().contains('FormatException')) {
            _logger.error('CustomerOrderService: Data format error - check database schema');
          } else if (e.toString().contains('TypeError')) {
            _logger.error('CustomerOrderService: Type error - check field types in database vs model');
          }

          // Continue processing other orders
        }
      }

      stopwatch.stop();
      final processingTime = stopwatch.elapsedMilliseconds;

      _logger.info(
        'CustomerOrderService: Order parsing completed - '
        'Success: $successCount, Failed: $failureCount, Total: ${response.length}, '
        'Processing time: ${processingTime}ms'
      );

      if (failureCount > 0) {
        _logger.warning(
          'CustomerOrderService: $failureCount orders failed to parse. '
          'Check logs above for specific error details.'
        );
      }

      return orders;
    } catch (e, stackTrace) {
      _logger.error('CustomerOrderService: Error fetching customer orders', e, stackTrace);

      // Provide more specific error handling based on error type
      if (_isNetworkError(e)) {
        _logger.warning('CustomerOrderService: Network error detected - check internet connection');
      } else if (e.toString().contains('PostgrestException')) {
        _logger.error('CustomerOrderService: Database query error - check RLS policies and table structure');
      } else if (e.toString().contains('AuthException')) {
        _logger.error('CustomerOrderService: Authentication error - user may need to re-login');
      } else {
        _logger.error('CustomerOrderService: Unexpected error type: ${e.runtimeType}');
      }

      // Always return empty list as fallback to prevent app crashes
      _logger.info('CustomerOrderService: Returning empty list as fallback');
      return [];
    }
  }

  /// Check if network is available for Supabase operations
  Future<bool> _isNetworkAvailable() async {
    try {
      // Try a simple DNS lookup to check connectivity
      final result = await InternetAddress.lookup('google.com');
      return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
    } catch (e) {
      _logger.warning('CustomerOrderService: Network availability check failed: $e');
      return false;
    }
  }

  /// Check if an error is network-related
  bool _isNetworkError(dynamic error) {
    final errorString = error.toString().toLowerCase();

    // Network-related error patterns
    final networkErrorPatterns = [
      'socketexception',
      'failed host lookup',
      'no address associated with hostname',
      'connection refused',
      'connection timed out',
      'network is unreachable',
      'no route to host',
      'authretryablefetchexception',
      'clientexception',
    ];

    for (final pattern in networkErrorPatterns) {
      if (errorString.contains(pattern)) {
        _logger.info('CustomerOrderService: Detected network error pattern: $pattern');
        return true;
      }
    }

    return false;
  }

  /// Map CustomerDeliveryMethod to database-compatible delivery method string
  String _mapCustomerDeliveryMethodToDatabase(CustomerDeliveryMethod method) {
    _logger.info('CustomerOrderService: Mapping delivery method: $method');

    String result;
    switch (method) {
      case CustomerDeliveryMethod.pickup:
        result = 'customer_pickup';
        break;
      case CustomerDeliveryMethod.delivery:
        result = 'own_fleet';
        break;
      case CustomerDeliveryMethod.scheduled:
        // For scheduled delivery, default to own fleet
        result = 'own_fleet';
        break;
    }

    _logger.info('CustomerOrderService: Mapped $method to $result');
    return result;
  }
}
