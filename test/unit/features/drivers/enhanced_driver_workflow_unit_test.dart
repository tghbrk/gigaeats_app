import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';

import 'package:gigaeats_app/src/features/drivers/data/models/driver_order.dart';
import 'package:gigaeats_app/src/features/orders/data/models/driver_order_state_machine.dart';
import 'package:gigaeats_app/src/features/drivers/data/validators/driver_workflow_validators.dart';
import 'package:gigaeats_app/src/features/drivers/data/services/driver_workflow_error_handler.dart';

// Mock classes are generated by build_runner
// Run: flutter packages pub run build_runner build --delete-conflicting-outputs

@GenerateMocks([])

/// Comprehensive unit tests for individual components of the enhanced driver workflow
void main() {
  group('Enhanced Driver Workflow Unit Tests', () {
    
    group('DriverOrderStateMachine Unit Tests', () {
      test('should validate all granular workflow transitions', () {
        // Test each valid transition individually
        final validTransitions = [
          (DriverOrderStatus.assigned, DriverOrderStatus.onRouteToVendor),
          (DriverOrderStatus.onRouteToVendor, DriverOrderStatus.arrivedAtVendor),
          (DriverOrderStatus.arrivedAtVendor, DriverOrderStatus.pickedUp),
          (DriverOrderStatus.pickedUp, DriverOrderStatus.onRouteToCustomer),
          (DriverOrderStatus.onRouteToCustomer, DriverOrderStatus.arrivedAtCustomer),
          (DriverOrderStatus.arrivedAtCustomer, DriverOrderStatus.delivered),
        ];

        for (final (from, to) in validTransitions) {
          final result = DriverOrderStateMachine.validateTransition(from, to);
          expect(result.isValid, isTrue, 
            reason: 'Transition from ${from.value} to ${to.value} should be valid');
        }
      });

      test('should reject invalid status transitions', () {
        final invalidTransitions = [
          (DriverOrderStatus.assigned, DriverOrderStatus.pickedUp), // Skip steps
          (DriverOrderStatus.onRouteToVendor, DriverOrderStatus.onRouteToCustomer), // Skip pickup
          (DriverOrderStatus.arrivedAtVendor, DriverOrderStatus.delivered), // Skip multiple steps
          (DriverOrderStatus.delivered, DriverOrderStatus.assigned), // Backward transition
          (DriverOrderStatus.cancelled, DriverOrderStatus.delivered), // From cancelled
        ];

        for (final (from, to) in invalidTransitions) {
          final result = DriverOrderStateMachine.validateTransition(from, to);
          expect(result.isValid, isFalse, 
            reason: 'Transition from ${from.value} to ${to.value} should be invalid');
        }
      });

      test('should identify mandatory confirmation requirements', () {
        // Test pickup confirmation requirement
        expect(DriverOrderStateMachine.requiresMandatoryConfirmation(DriverOrderStatus.arrivedAtVendor), 
          isTrue, reason: 'Pickup confirmation should be mandatory at vendor');
        
        // Test delivery confirmation requirement
        expect(DriverOrderStateMachine.requiresMandatoryConfirmation(DriverOrderStatus.arrivedAtCustomer), 
          isTrue, reason: 'Delivery confirmation should be mandatory at customer');
        
        // Test non-confirmation statuses
        expect(DriverOrderStateMachine.requiresMandatoryConfirmation(DriverOrderStatus.onRouteToVendor), 
          isFalse, reason: 'Navigation should not require confirmation');
      });

      test('should provide correct confirmation types', () {
        expect(DriverOrderStateMachine.getRequiredConfirmationType(DriverOrderStatus.arrivedAtVendor), 
          equals('pickup'), reason: 'Vendor arrival should require pickup confirmation');
        
        expect(DriverOrderStateMachine.getRequiredConfirmationType(DriverOrderStatus.arrivedAtCustomer), 
          equals('delivery'), reason: 'Customer arrival should require delivery confirmation');
        
        expect(DriverOrderStateMachine.getRequiredConfirmationType(DriverOrderStatus.onRouteToVendor), 
          isNull, reason: 'Navigation should not require confirmation');
      });

      test('should provide appropriate driver instructions', () {
        final instructionTests = [
          (DriverOrderStatus.assigned, 'navigate'),
          (DriverOrderStatus.onRouteToVendor, 'navigate'),
          (DriverOrderStatus.arrivedAtVendor, 'confirm'),
          (DriverOrderStatus.pickedUp, 'navigate'),
          (DriverOrderStatus.onRouteToCustomer, 'navigate'),
          (DriverOrderStatus.arrivedAtCustomer, 'confirm'),
          (DriverOrderStatus.delivered, 'complete'),
        ];

        for (final (status, expectedKeyword) in instructionTests) {
          final instructions = DriverOrderStateMachine.getDriverInstructions(status);
          expect(instructions, isNotEmpty, 
            reason: 'Instructions for ${status.value} should not be empty');
          expect(instructions.toLowerCase(), contains(expectedKeyword), 
            reason: 'Instructions for ${status.value} should contain "$expectedKeyword"');
        }
      });
    });

    group('DriverWorkflowValidators Unit Tests', () {
      test('should validate pickup confirmation data correctly', () {
        // Test valid pickup confirmation
        final validChecklist = {
          'Order number matches': true,
          'All items are present': true,
          'Items are properly packaged': true,
          'Special instructions noted': true,
          'Temperature requirements met': true,
        };

        final validResult = DriverWorkflowValidators.validatePickupConfirmationData(
          verificationChecklist: validChecklist,
          notes: 'All items verified',
        );

        expect(validResult.isValid, isTrue, 
          reason: 'Valid pickup confirmation should pass validation');
      });

      test('should reject pickup confirmation with insufficient verification', () {
        // Test with critical items not verified
        final invalidChecklist = {
          'Order number matches': true,
          'All items are present': false, // Critical item not verified
          'Items are properly packaged': true,
        };

        final invalidResult = DriverWorkflowValidators.validatePickupConfirmationData(
          verificationChecklist: invalidChecklist,
          notes: null,
        );

        expect(invalidResult.isValid, isFalse, 
          reason: 'Pickup confirmation with unverified critical items should fail');
        expect(invalidResult.errorMessage, contains('verification'), 
          reason: 'Error message should mention verification requirement');
      });

      test('should enforce 80% completion rule for pickup checklist', () {
        // Test with only 40% completion (2 out of 5 items)
        final partialChecklist = {
          'Order number matches': true,
          'All items are present': true,
          'Items are properly packaged': false,
          'Special instructions noted': false,
          'Temperature requirements met': false,
        };

        final result = DriverWorkflowValidators.validatePickupConfirmationData(
          verificationChecklist: partialChecklist,
          notes: null,
        );

        expect(result.isValid, isFalse, 
          reason: 'Should enforce 80% completion rule');
        expect(result.errorMessage, contains('80%'), 
          reason: 'Error message should mention 80% requirement');
      });

      test('should validate delivery confirmation data correctly', () {
        // Test valid delivery confirmation
        final validResult = DriverWorkflowValidators.validateDeliveryConfirmationData(
          photoUrl: 'https://example.com/delivery-proof.jpg',
          latitude: 3.1390,
          longitude: 101.6869,
          accuracy: 5.0,
          recipientName: 'John Doe',
          notes: 'Delivered successfully',
        );

        expect(validResult.isValid, isTrue, 
          reason: 'Valid delivery confirmation should pass validation');
      });

      test('should reject delivery confirmation without mandatory photo', () {
        final result = DriverWorkflowValidators.validateDeliveryConfirmationData(
          photoUrl: null, // Missing mandatory photo
          latitude: 3.1390,
          longitude: 101.6869,
          accuracy: 5.0,
          recipientName: 'John Doe',
          notes: 'Attempted delivery without photo',
        );

        expect(result.isValid, isFalse, 
          reason: 'Should reject delivery without photo');
        expect(result.errorMessage, contains('photo'), 
          reason: 'Error message should mention photo requirement');
      });

      test('should reject delivery confirmation with poor GPS accuracy', () {
        final result = DriverWorkflowValidators.validateDeliveryConfirmationData(
          photoUrl: 'https://example.com/delivery-proof.jpg',
          latitude: 3.1390,
          longitude: 101.6869,
          accuracy: 150.0, // Poor accuracy > 100m
          recipientName: 'John Doe',
          notes: 'Delivery with poor GPS signal',
        );

        expect(result.isValid, isFalse, 
          reason: 'Should reject delivery with poor GPS accuracy');
        expect(result.errorMessage, contains('accuracy'), 
          reason: 'Error message should mention accuracy requirement');
      });

      test('should validate order status transitions with business rules', () {
        final testOrder = _createTestDriverOrder(DriverOrderStatus.assigned);

        // Test valid transition
        final validResult = DriverWorkflowValidators.validateOrderStatusTransition(
          order: testOrder,
          targetStatus: DriverOrderStatus.onRouteToVendor,
        );
        expect(validResult.isValid, isTrue, 
          reason: 'Valid status transition should pass validation');

        // Test invalid transition (skipping steps)
        final invalidResult = DriverWorkflowValidators.validateOrderStatusTransition(
          order: testOrder,
          targetStatus: DriverOrderStatus.pickedUp, // Skipping steps
        );
        expect(invalidResult.isValid, isFalse, 
          reason: 'Invalid status transition should fail validation');
      });
    });

    group('DriverWorkflowErrorHandler Unit Tests', () {
      test('should handle network failures with retry logic', () async {
        final errorHandler = DriverWorkflowErrorHandler();
        int attemptCount = 0;

        final result = await errorHandler.handleWorkflowOperation<String>(
          operation: () async {
            attemptCount++;
            if (attemptCount < 3) {
              throw Exception('Network timeout');
            }
            return 'Success after retries';
          },
          operationName: 'test_operation',
          maxRetries: 3,
          requiresNetwork: true,
        );

        expect(result.isSuccess, isTrue, 
          reason: 'Should succeed after retries');
        expect(result.data, equals('Success after retries'));
        expect(attemptCount, equals(3), 
          reason: 'Should retry the correct number of times');
      });

      test('should fail after maximum retries exceeded', () async {
        final errorHandler = DriverWorkflowErrorHandler();
        int attemptCount = 0;

        final result = await errorHandler.handleWorkflowOperation<String>(
          operation: () async {
            attemptCount++;
            throw Exception('Persistent network failure');
          },
          operationName: 'test_operation',
          maxRetries: 2,
          requiresNetwork: true,
        );

        expect(result.isSuccess, isFalse, 
          reason: 'Should fail after maximum retries');
        expect(attemptCount, equals(3), // Initial attempt + 2 retries
          reason: 'Should attempt the correct number of times');
      });

      test('should handle non-network errors without retry', () async {
        final errorHandler = DriverWorkflowErrorHandler();
        int attemptCount = 0;

        final result = await errorHandler.handleWorkflowOperation<String>(
          operation: () async {
            attemptCount++;
            throw ArgumentError('Invalid input');
          },
          operationName: 'test_operation',
          maxRetries: 3,
          requiresNetwork: false,
        );

        expect(result.isSuccess, isFalse, 
          reason: 'Should fail for non-network errors');
        expect(attemptCount, equals(1), 
          reason: 'Should not retry for non-network errors');
      });
    });
  });
}

/// Helper function to create test driver order
DriverOrder _createTestDriverOrder(DriverOrderStatus status) {
  final now = DateTime.now();
  return DriverOrder(
    id: 'test-order-id',
    orderId: 'order-12345',
    orderNumber: 'ORD-12345',
    driverId: 'test-driver-id',
    vendorId: 'test-vendor-id',
    vendorName: 'Test Restaurant',
    customerId: 'test-customer-id',
    customerName: 'Test Customer',
    status: status,
    deliveryDetails: const DeliveryDetails(
      pickupAddress: '456 Restaurant Street, Test City',
      deliveryAddress: '123 Test Street, Test City',
      contactPhone: '+60123456789',
    ),
    orderEarnings: const OrderEarnings(
      baseFee: 5.0,
      totalEarnings: 8.50,
    ),
    orderItemsCount: 3,
    orderTotal: 25.50,
    assignedAt: now.subtract(const Duration(hours: 1)),
    createdAt: now.subtract(const Duration(hours: 1)),
    updatedAt: now,
    deliveryNotes: 'Test delivery notes',
    requestedDeliveryTime: now.add(const Duration(minutes: 30)),
  );
}
